Index: features/everything.feature
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>Feature: A game of connect-4\r\nScenario: Starting the game and quitting\r\n   Given starting main.py\r\n   When the user selects Quit\r\n   Then the game closes itself\r\n\r\nScenario: Starting the game and choosing 'Play Game'\r\n   Given starting main.py\r\n   When the user selects \"Play Game\"\r\n   Then the user gets transferred to the next menu\r\n\r\nScenario: Going back to the start menu\r\n   Given starting main.py\r\n   When the user is in the gamemode menu\r\n   When the user selects the <- back button\r\n   Then the user gets transferred to the start menu\r\n\r\n#Scenario: Selecting 'Player vs Player'\r\n#   Given the user is in the gamemode menu\r\n#   When the user selects \"Player vs Player\"\r\n#   Then the selected gamemode starts\r\n\r\n#Scenario: Player's turn is valid\r\n#   Given the Player selects column <columns>\r\n#   When the move is valid\r\n#   Then a checker has to be in the lowest free row of the selected column\r\n\r\n#Scenario: Player's turn is invalid\r\n#   Given Player selects column <columns>\r\n#   When the move is invalid\r\n#   Then the message \"this column is already full!\" appears as long as the input is invalid\r\n\r\n#Scenario: Player wins\r\n#   Given two players play against each other\r\n#   When a player wins\r\n#   Then there is a congratulation message\r\n#   And the user can return back to the main menu\r\n\r\n#Scenario: Draw\r\n#   Given two players play against each other\r\n#   When the board is full\r\n#   And no one has won\r\n#   Then the message \"The game is a draw!\" appears\r\n#   And the user can return back to the main menu\r\n\r\nScenario: Quitting during game\r\n   Given starting main.py\r\n   When there is a game running\r\n   And the Quit button is selected\r\n   Then the game quits\r\n   And the user will be asked if they want to save the game\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/features/everything.feature b/features/everything.feature
--- a/features/everything.feature	
+++ b/features/everything.feature	
@@ -1,19 +1,19 @@
 Feature: A game of connect-4
-Scenario: Starting the game and quitting
-   Given starting main.py
-   When the user selects Quit
-   Then the game closes itself
+#Scenario: Starting the game and quitting
+#   Given starting main.py
+#   When the user selects Quit
+#   Then the game closes itself
 
-Scenario: Starting the game and choosing 'Play Game'
-   Given starting main.py
-   When the user selects "Play Game"
-   Then the user gets transferred to the next menu
+#Scenario: Starting the game and choosing 'Play Game'
+#   Given starting main.py
+#   When the user selects "Play Game"
+#   Then the user gets transferred to the next menu
 
-Scenario: Going back to the start menu
-   Given starting main.py
-   When the user is in the gamemode menu
-   When the user selects the <- back button
-   Then the user gets transferred to the start menu
+#Scenario: Going back to the start menu
+#   Given starting main.py
+#   When the user is in the gamemode menu
+#   When the user selects the <- back button
+#   Then the user gets transferred to the start menu
 
 #Scenario: Selecting 'Player vs Player'
 #   Given the user is in the gamemode menu
@@ -25,27 +25,30 @@
 #   When the move is valid
 #   Then a checker has to be in the lowest free row of the selected column
 
-#Scenario: Player's turn is invalid
-#   Given Player selects column <columns>
-#   When the move is invalid
-#   Then the message "this column is already full!" appears as long as the input is invalid
+Scenario: Player's turn is invalid
+   Given starting main.py
+   When Player selects column <columns>
+   And the move is invalid
+   Then the message "this column is already full!" appears as long as the input is invalid
 
 #Scenario: Player wins
-#   Given two players play against each other
-#   When a player wins
+#   Given starting main.py
+#   When two players play against one another
+#   And a player wins
 #   Then there is a congratulation message
 #   And the user can return back to the main menu
 
 #Scenario: Draw
-#   Given two players play against each other
-#   When the board is full
+#   Given starting main.py
+#   When two players play against each other
+#   And the board is full
 #   And no one has won
 #   Then the message "The game is a draw!" appears
 #   And the user can return back to the main menu
 
-Scenario: Quitting during game
-   Given starting main.py
-   When there is a game running
-   And the Quit button is selected
-   Then the game quits
-   And the user will be asked if they want to save the game
+#Scenario: Quitting during game
+#   Given starting main.py
+#   When there is a game running
+#   And the Quit button is selected
+#   Then the game quits
+#   And the user will be asked if they want to save the game
Index: features/steps/steps.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from behave import given, when, then\r\nimport wexpect\r\nfrom init import init\r\n\r\n'''\r\nNotes: Whenever you start a scenario, start with Given starting main.py in everything.feature to setup the environment\r\nYou can send a user input with context.child.sendline(Your command in String)\r\nYou can also expect a String from the console with context.child.expect(Expected String)\r\nIt is important for testing purposes that you setup the timer correctly. Right now we are using the timeout of 3.\r\nIf the timeout is not set correctly, it will stop behave for 2 minutes so please dont forget that.\r\nExample: context.child.expect(\"Connect 4 Main Menu\", timeout=3)\r\n\r\nYou can also debug behave.\r\nI created a file called behave.ini which allows us to read printed statements.\r\nTo turn it on, just put both stderr_capture and stdout_capture to False.\r\n(Tip: if you want to work on your scenario only without reading debugging messages from other scenarios,\r\ncomment every other scenario except yours in everything.feature with #. This make your scenario isolated.)\r\nTo print console or user input just use\r\nprint(context.child.before, end='')\r\nprint(context.child.after, end='')\r\n\r\n-Johni\r\n'''\r\n\r\n'''\r\nBtw, I also created a file called init.py where you can change your project directory more easier.\r\nJust change the project_path variable.\r\n\r\n-Johni\r\n'''\r\n\r\n@given('starting main.py')\r\ndef step_impl(context):\r\n    # Start cmd as child process\r\n    context.child = wexpect.spawn('cmd.exe')\r\n    # Change into right directory\r\n    cmd_commands = [\"cd \" + init.project_path, init.start_game]\r\n\r\n    # Loops through cmd commands\r\n    for command in cmd_commands:\r\n        context.child.expect('>', timeout=3)\r\n        context.child.sendline(command)\r\n        print(context.child.before, end='')\r\n        print(context.child.after, end='')\r\n\r\n# Scenario: Starting the game and quitting\r\n@when('the user selects Quit')\r\ndef step_impl(context):\r\n    # Expecting from console and sending input\r\n    context.child.expect('Please select an option: ', timeout=3)\r\n    context.child.sendline('3')\r\n    print(context.child.before, end='')\r\n    print(context.child.after, end='')\r\n\r\n@then('the game closes itself')\r\ndef step_impl(context):\r\n    # Expecting Goodbye! from console\r\n    context.child.expect('Goodbye!', timeout=3)\r\n    print(context.child.before, end='')\r\n    print(context.child.after, end='')\r\n\r\n# Scenario: Starting the game and choosing 'Play Game'\r\n@when('the user selects \"Play Game\"')\r\ndef step_impl(context):\r\n    # Expects to be in main menu and gets into game mode menu\r\n    context.child.expect('~Connect 4 Main Menu~', timeout=3)\r\n    context.child.sendline('1')\r\n    print(context.child.before, end='')\r\n    print(context.child.after, end='')\r\n\r\n@then('the user gets transferred to the next menu')\r\ndef step_impl(context,):\r\n    # Expects to be in game mode menu\r\n    context.child.expect('~Game Mode Selection Menu~', timeout=3)\r\n    print(context.child.before, end='')\r\n    print(context.child.after, end='')\r\n\r\n# Scenario: Going back to the start menu\r\n@when('the user is in the gamemode menu')\r\ndef step_impl(context):\r\n    # Expecting to be in Main menu and going into gamemode menu\r\n    context.child.expect('Please select an option: ', timeout=3)\r\n    context.child.sendline('1')\r\n    print(context.child.before, end='')\r\n    print(context.child.after, end='')\r\n\r\n@when('the user selects the <- back button')\r\ndef step_impl(context):\r\n    # Selecting <- back button\r\n    context.child.expect('Game Mode Selection Menu', timeout=3)\r\n    context.child.sendline('4')\r\n    print(context.child.before, end='')\r\n    print(context.child.after, end='')\r\n\r\n@then('the user gets transferred to the start menu')\r\ndef step_impl(context):\r\n    # Expecting to be in main menu\r\n    context.child.expect('Connect 4 Main Menu', timeout=3)\r\n    print(context.child.before, end='')\r\n    print(context.child.after, end='')\r\n\r\n# Scenario: Quitting during game\r\n@when('there is a game running')\r\ndef step_impl(context):\r\n    # Sets up the game\r\n    menu_selection = {'~Connect 4 Main Menu~': '1', 'Game Mode Selection Menu': '1'}\r\n\r\n    # Goes through the menus to select 'Player vs Player'\r\n    for expect, send in menu_selection.items():\r\n        context.child.expect(expect, timeout=3)\r\n        context.child.sendline(send)\r\n        print(context.child.before, end='')\r\n        print(context.child.after, end='')\r\n\r\n    # In game\r\n    context.child.expect('Which column do you want to place your checker?', timeout=3)\r\n    print(context.child.before, end='')\r\n    print(context.child.after, end='')\r\n\r\n@when('the Quit button is selected')\r\ndef step_impl(context):\r\n    # Selects quit button during game\r\n    context.child.expect('Please select an option:', timeout=3)\r\n    context.child.sendline('8')\r\n    print(context.child.before, end='')\r\n    print(context.child.after, end='')\r\n\r\n@then('the game quits')\r\ndef step_impl(context):\r\n    # Game should quit\r\n    context.child.expect('You have chosen \"quit\"', timeout=3)\r\n    print(context.child.before, end='')\r\n    print(context.child.after, end='')\r\n\r\n@then('the user will be asked if they want to save the game')\r\ndef step_impl(context):\r\n    # User should be asked if they want to save the game\r\n    context.child.expect('Do you want to save the current game?', timeout=3)\r\n    print(context.child.before, end='')\r\n    print(context.child.after, end='')\r\n\r\n'''\r\n@given('the user is in the gamemode menu')\r\n@when('the user selects the \"<- back\" button')\r\n@then('the user gets transferred to the start menu')\r\n\r\n\r\n@given('the user is in the gamemode menu')\r\n@when('the user selects \"Player vs Player\"')\r\n@then('the selected gamemode starts')\r\n\r\n\r\n@given('the Player selects column <columns>')\r\n@when('the move is valid')\r\n@then('a checker has to be in the lowest free row of the selected column')\r\n\r\n\r\n@given('Player selects column <columns>')\r\n@when('the move is invalid')\r\n@then('the message \"this column is already full!\" appears as long as the input is invalid')\r\n\r\n\r\n@given('two players play against each other')\r\n@when('a player wins')\r\n@then('there is a congratulation message')\r\n@then('the user can return back to the main menu')\r\n\r\n\r\n@given('two players play against each other')\r\n@when('the board is full')\r\n@when('no one has won')\r\n@then('the message \"The game is a draw!\" appears')\r\n@then('the user can return back to the main menu')\r\n\r\n\r\n@given('there is a game running')\r\n@when('the \"quit\" button is selected')\r\n@then('the user will be asked if they want to save the game')\r\n'''\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/features/steps/steps.py b/features/steps/steps.py
--- a/features/steps/steps.py	
+++ b/features/steps/steps.py	
@@ -99,6 +99,103 @@
     print(context.child.before, end='')
     print(context.child.after, end='')
 
+#Scenario: Player's turn is invalid
+@when('Player selects column <columns>')
+def step_impl(context):
+    context.child.expect('Please select an option: ', timeout=3)
+    context.child.sendline('1')
+    print(context.child.before, end='')
+    print(context.child.after, end='')
+
+    context.child.expect('Please select an option: ', timeout=3)
+    context.child.sendline('1')
+    print(context.child.before, end='')
+    print(context.child.after, end='')
+
+    for row in range(8):
+        context.child.expect('Please select an option: ', timeout=3)
+        chosen_column = str(row+1)
+        context.child.sendline(chosen_column)
+
+@when('the move is invalid')
+def step_impl(context):
+    #Expecting that the turn of the current Player is invalid
+    context.child.expect('invalid', timeout=3)
+    print(context.child.before, end='')
+    print(context.child.after, end='')
+
+@then('the message "this column is already full!" appears as long as the input is invalid')
+def step_impl(context):
+    #the message should appear in the console
+    context.child.expect('this column is already full!', timeout=3)
+    print(context.child.before, end='')
+    print(context.child.after, end='')
+
+#Scenario: Player wins
+@when('two players play against one another')
+def step_impl(context):
+    pass
+
+
+@when('a player wins')
+def step_impl(context):
+    #Expected, that the player wins the game
+    context.child.expect('Player wins', timeout=3)
+    print(context.child.before, end='')
+    print(context.child.after, end='')
+
+@when('there is a congratulation message')
+def step_impl(context):
+    #A message appears, which congratulates the player for winning the game
+    context.child.expect('Congratulation message appears', timeout=3)
+    context.child.sendline('')
+    print(context.child.before, end='')
+    print(context.child.after, end='')
+
+@then('the user can return back to the main menu')
+def step_impl(context):
+    #The user can now go back to the menu
+    context.child.expect('Menu appears', timeout=3)
+    context.child.sendline('')
+    print(context.child.before, end='')
+    print(context.child.after, end='')
+
+#Scenario: Draw
+@when('two players play against each other')
+def step_impl(context):
+    pass
+
+
+@when('the board is full')
+def step_impl(context):
+    #No one can set checkers anymore, because the board is already full
+    context.child.expect('full board', timeout=3)
+    context.child.sendline('')
+    print(context.child.before, end='')
+    print(context.child.after, end='')
+
+@then('no one has won')
+def step_impl(context):
+    #expected, that the game will be over and no one has won
+    context.child.expect('it is a draw', timeout=3)
+    print(context.child.before, end='')
+    print(context.child.after, end='')
+
+@when('the message "The game is a draw!" appears')
+def step_impl(context):
+    #Now it is game over and a message shows up
+    context.child.expect('"The game is a draw!"', timeout=3)
+    print(context.child.before, end='')
+    print(context.child.after, end='')
+
+@then('the user is able to return back to the main menu')
+def step_impl(context):
+    #The player should be able to go back to the menu
+    context.child.expect('Menu appears', timeout=3)
+    context.child.sendline('')
+    print(context.child.before, end='')
+    print(context.child.after, end='')
+
 # Scenario: Quitting during game
 @when('there is a game running')
 def step_impl(context):
Index: features/steps/init.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>class init:\r\n    project_path = r\"C:\\Users\\johnt\\Desktop\\RandomScripts\\connect-4\"\r\n    start_game = \"python main.py\"
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/features/steps/init.py b/features/steps/init.py
--- a/features/steps/init.py	
+++ b/features/steps/init.py	
@@ -1,3 +1,3 @@
 class init:
-    project_path = r"C:\Users\johnt\Desktop\RandomScripts\connect-4"
+    project_path = r"C:\Users\louis\PycharmProjects\connect-4"
     start_game = "python main.py"
\ No newline at end of file
Index: behave.ini
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>[behave]\r\nstderr_capture=True\r\nstdout_capture=True
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/behave.ini b/behave.ini
--- a/behave.ini	
+++ b/behave.ini	
@@ -1,3 +1,3 @@
 [behave]
-stderr_capture=True
-stdout_capture=True
\ No newline at end of file
+stderr_capture=False
+stdout_capture=False
\ No newline at end of file
